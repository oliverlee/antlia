#!/usr/bin/env python
# -*- coding: utf-8 -*-
import numpy as np
import h5py


def load_file(filename, calibration_dict=None):
    if filename.endswith('.csv'):
        data = load_etrike(filename)
        return convert_etrike(data, calibration_dict)
    elif filename.endswith('.h5'):
        data = load_imuwnet(filename)
        r = convert_imuwnet(data)
        for d in data:
            try:
                d.close()
            except AttributeError:
                pass
        return r


def load_etrike(filename):
    # steer angle and speed are sampled as integer types but we later convert
    # them to floats for plotting
    return np.recfromcsv(filename, delimiter=',', dtype=np.float64,
                         invalid_raise=False)


def convert_etrike(record, calibration_dict):
    """ Convert record fields from sampled unit to SI unit using provided
        calibration_dict generated by calibrate.py.
        This function is idempotent as is uses the names of the record fields
        to determine if conversion should occur.

        Returns True if conversion is performed.
    """
    names = list(record.dtype.names)
    newnames = ['time']
    if names[0] == newnames[0]:
        return record

    for name in names[1:]:
        if name.startswith('acc'):
            newname = 'accelerometer ' + name[3]
        elif name.startswith('gyro'):
            newname = 'gyroscope ' + name[4]
        elif name == 'steerangle_lsb':
            newname = 'steer angle'
        elif name == 'speed_lsb':
            newname = 'speed'
        else:
            raise ValueError(
                'conversion for signal {} is not defined'.format(name))
        # conversion assumes linear relationship incorporates both calibration
        # and unit conversion
        record[name] = np.polyval(calibration_dict[newname],
                                  record[name])
        newnames.append(newname)

    record.dtype.names = newnames
    return record


def load_imuwnet(filename):
    """ Data from Cain, 2016, Measurement of bicycle and rider kinematics during
    real-world cycling using a wireless array of inertial sensors.
    """
    # 'raw' imu data
    f = h5py.File(filename, 'r')
    try:
        # mat file with calculated speed, steer angle, etc.
        g = h5py.File(filename + '.mat', 'r')
    except OSError:
        g = None
    return (f, g)


def convert_imuwnet(data):
    f, g = data

    # frame data corresponds to imu SI-002767
    dataset = f['SI-002767']
    acc = dataset['Calibrated/Accelerometers'].value
    gyro = dataset['Calibrated/Gyroscopes'].value
    t = dataset['Time'].value.flatten()
    t -= t[0] # redefine first sample to be at time zero
    t = t.astype(np.float) # convert from unsigned integer to floating type
    t /= 1000000 # convert microseconds to seconds

    names = ['time',
             'accelerometer x',
             'accelerometer y',
             'accelerometer z',
             'gyroscope x',
             'gyroscope y',
             'gyroscope z']
    split = lambda x: [y.flatten() for y in np.split(x, 3, axis=1)]
    signals = [t] + split(acc) + split(gyro)

    if g is not None:
        names = names[:1] + ['steer angle', 'speed'] + names[1:]
        g_signals = [g['data/{}'.format(s)].value.flatten()
                     for s in ['steer_angle', 'speed']]
        signals = signals[:1] + g_signals + signals[1:]

    r = np.rec.fromarrays(signals, names=names)
    return r
