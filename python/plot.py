#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


def signal_unit(s):
    # return the SI unit for a signal name
    if s.startswith('accelerometer'):
        return 'm/s^2'
    elif s.startswith('gyroscope'):
        return 'rad/s'
    elif 'angle' in s:
        return 'rad'
    elif s.startswith('speed'):
        return 'm/s'
    else:
        raise ValueError('unit for signal {} is not defined'.format(s))


def get_subplot_grid(record):
    # time is the first field
    assert record.dtype.names[0] == 'time'

    n = len(record.dtype.names) - 1
    cols = 3 if not n % 3 else 2
    rows = int(np.ceil(n / cols))
    return rows, cols


def plot_timeseries(record):
    # check that record dtype doesn't contain nested dtypes
    assert all(np.issubdtype(record.dtype[i], np.number)
               for i in range(len(record.dtype)))

    names = record.dtype.names
    t = record[names[0]]
    signals = names[1:]
    colors = sns.color_palette('husl', len(signals))

    rows, cols = get_subplot_grid(record)
    fig, axes = plt.subplots(rows, cols, sharex=True)
    for ax, signal, color in zip(axes.ravel(), signals, colors):
        ax.plot(t, record[signal], label=signal, color=color)
        ax.set_xlabel('time [s]')
        ax.set_ylabel(signal_unit(signal))
        ax.legend()

    return fig, axes


def convert_record(record, calibration_dict):
    """ Convert record fields from sampled unit to SI unit using provided
        calibration_dict generated by calibrate.py.
        This function is idempotent as is uses the names of the record fields
        to determine if conversion should occur.

        Returns True if conversion is performed.
    """
    names = list(record.dtype.names)
    newnames = ['time']
    if names[0] == newnames[0]:
        print(names, newnames)
        return False

    for name in names[1:]:
        if name.startswith('acc'):
            newname = 'accelerometer ' + name[3]
        elif name.startswith('gyro'):
            newname = 'gyroscope ' + name[4]
        elif name == 'steerangle_lsb':
            newname = 'steer angle'
        elif name == 'speed_lsb':
            newname = 'speed'
        else:
            raise ValueError(
                'conversion for signal {} is not defined'.format(name))
        # conversion assumes linear relationship incorporates both calibration
        # and unit conversion
        record[name] = np.polyval(calibration_dict['convbike'][newname],
                                  record[name])
        newnames.append(newname)

    record.dtype.names = newnames
    return True


def load_record(filename):
    # steer angle and speed are sampled as integer types but we later convert
    # them to floats for plotting
    return np.recfromcsv(filename, delimiter=',', dtype=np.float64)


if __name__ == '__main__':
    if len(sys.argv) > 1:
        path = sys.argv[1]
    else:
        import glob
        pathname = os.path.join(os.path.dirname(__file__),
                r'data/experiment/rider3/convbike/*.csv')
        filenames = glob.glob(pathname)
        path = filenames[3]
    r = load_record(path)

    import pickle
    with open('config.p', 'rb') as f:
        cd = pickle.load(f)

    convert_record(r, cd)
    fig, axes = plot_timeseries(r)
    fig.suptitle(path)
    plt.show()
