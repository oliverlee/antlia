#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


def signal_unit(s):
    # return the SI unit for a signal name
    if s.startswith('acc'):
        return 'm/s^2'
    elif s.startswith('gyro'):
        return 'rad/s'
    elif 'angle' in s:
        return 'rad'
    elif s.startswith('speed'):
        return 'm/s'
    else:
        raise ValueError('unit for signal {} is not defined'.format(s))


def convert_record(r, calibration_dict):
    """ Convert record fields from sampled unit to SI unit using provided
        calibration_dict generated by calibrate.py.
        This function is idempotent as is uses the names of the record fields
        to determine if conversion should occur.

        Returns True if conversion is performed.
    """
    names = list(r.dtype.names)
    newnames = ['time']
    if names[0] == newnames[0]:
        print(names, newnames)
        return False

    for name in names[1:]:
        if name.startswith('acc'):
            newname = name[:4]
        elif name.startswith('gyro'):
            newname = name[:5]
        elif name == 'steerangle_lsb':
            newname = 'steer_angle'
        elif name == 'speed_lsb':
            newname = 'speed'
        else:
            raise ValueError(
                'conversion for signal {} is not defined'.format(name))
        # conversion assumes linear relationship incorporates both calibration
        # and unit conversion
        r[name] = np.polyval(calibration_dict['convbike'][newname],
                             r[name])
        newnames.append(newname)

    r.dtype.names = newnames
    return True


def load_record(filename):
    # steer angle and speed are sampled as integer types but we later convert
    # them to floats
    return np.recfromcsv(filename, delimiter=',', dtype=np.float64)


def plot_record(r):
    # check that record dtype doesn't contain nested dtypes
    assert all(np.issubdtype(r.dtype[i], np.number)
               for i in range(len(r.dtype)))

    names = r.dtype.names
    # time is the first field
    assert r.dtype.names[0] == 'time'

    t = r[names[0]]
    signals = names[1:]
    colors = sns.color_palette('deep', len(signals))

    cols = 2
    rows = len(signals) // cols
    fig, axes = plt.subplots(rows, cols, sharex=True)
    for ax, signal, color in zip(axes.ravel(), signals, colors):
        ax.plot(t, r[signal], label=signal, color=color)
        ax.set_xlabel('time [s]')
        ax.set_ylabel(signal_unit(signal))
        ax.legend()

    return fig, axes


if __name__ == '__main__':
    if len(sys.argv) > 1:
        path = sys.argv[1]
    else:
        import glob
        pathname = os.path.join(os.path.dirname(__file__),
                r'data/experiment/rider3/convbike/*.csv')
        filenames = glob.glob(pathname)
        path = filenames[3]
    r = load_record(path)

    import pickle
    with open('config.p', 'rb') as f:
        cd = pickle.load(f)

    convert_record(r, cd)
    fig, axes = plot_record(r)
    fig.suptitle(path)
    plt.show()
